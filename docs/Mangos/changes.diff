@@ -75,10 +75,11 @@
 #include "Weather.h"
 #include "LFGMgr.h"
 #ifdef ENABLE_ELUNA
 #include "LuaEngine.h"
 #endif /*ENABLE_ELUNA*/
+#include "MercenaryMgr.h"
 
 // Warden
 #include "WardenCheckMgr.h"
 
 #include <iostream>
@@ -1446,10 +1447,12 @@ void World::SetInitialWorldSettings()
     // in multithread foreach: run scripts
     sEluna->RunScripts();
     sEluna->OnConfigLoad(false); // Must be done after Eluna is initialized and scripts have run.
 #endif
 
+    sMercenaryMgr->LoadMercenaries();
+
     sLog.outString("WORLD: World initialized");
 
     uint32 uStartInterval = WorldTimer::getMSTimeDiff(uStartTime, WorldTimer::getMSTime());
     sLog.outString("SERVER STARTUP TIME: %i minutes %i seconds", uStartInterval / 60000, (uStartInterval % 60000) / 1000);
 }

@@ -303,10 +303,15 @@ bool Creature::InitEntry(uint32 Entry, CreatureData const* data /*=NULL*/, GameE
     {
         sLog.outErrorDb("Creature (Entry: %u) has no model defined in table `creature_template`, can't load.", Entry);
         return false;
     }
 
+	if (GetScriptName() == "mercenary_bot")
+       SetFlag(UNIT_FIELD_FLAGS_2, 16);
+	else
+       RemoveFlag(UNIT_FIELD_FLAGS_2, 16);
+
     CreatureModelInfo const* minfo = sObjectMgr.GetCreatureModelRandomGender(display_id);
     if (!minfo)                                             // Cancel load if no model defined
     {
         sLog.outErrorDb("Creature (Entry: %u) has no model info defined in table `creature_model_info`, can't load.", Entry);
         return false;
@@ -407,10 +412,14 @@ bool Creature::UpdateEntry(uint32 Entry, Team team, const CreatureData* data /*=
     // we may need to append or remove additional flags
     if (HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IN_COMBAT))
         { unitFlags |= UNIT_FLAG_IN_COMBAT; }
 
     SetUInt32Value(UNIT_FIELD_FLAGS, unitFlags);
+	if (GetScriptName() == "mercenary_bot")
+       SetUInt32Value(UNIT_FIELD_FLAGS_2,  16);
+	else
+       SetUInt32Value(UNIT_FIELD_FLAGS_2, 0);
 
     // preserve all current dynamic flags if exist
     uint32 dynFlags = GetUInt32Value(UNIT_DYNAMIC_FLAGS);
     SetUInt32Value(UNIT_DYNAMIC_FLAGS, dynFlags ? dynFlags : GetCreatureInfo()->DynamicFlags);
	 
@@ -37,11 +37,11 @@ INSTANTIATE_SINGLETON_1(MovementGeneratorRegistry);
 namespace FactorySelector
 {
     CreatureAI* selectAI(Creature* creature)
     {
         // Allow scripting AI for normal creatures and not controlled pets (guardians and mini-pets)
-        if ((!creature->IsPet() || !((Pet*)creature)->isControlled()) && !creature->IsCharmed())
+        if (creature->GetScriptName() == "mercenary_bot" || (!creature->IsPet() || !((Pet*)creature)->isControlled()) && !creature->IsCharmed())
             if (CreatureAI* scriptedAI = sScriptMgr.GetCreatureAI(creature))
                 { return scriptedAI; }
 
         CreatureAIRegistry& ai_registry(CreatureAIRepository::Instance());
		 
@@ -31,10 +31,11 @@
 #include "Formulas.h"
 #include "SpellAuras.h"
 #include "CreatureAI.h"
 #include "Unit.h"
 #include "Util.h"
+#include "MercenaryMgr.h"
 
 Pet::Pet(PetType type) :
     Creature(CREATURE_SUBTYPE_PET),
     m_resetTalentsCost(0), m_resetTalentsTime(0), m_usedTalentCount(0),
     m_removed(false), m_happinessTimer(7500), m_petType(type), m_duration(0),
@@ -302,10 +303,11 @@ bool Pet::LoadPetFromDB(Player* owner, uint32 petentry, uint32 petnumber, bool c
     CleanupActionBar();                                     // remove unknown spells from action bar after load
 
     _LoadSpellCooldowns();
 
     owner->SetPet(this);                                    // in DB stored only full controlled creature
+    sMercenaryMgr->OnSummon(owner);
     DEBUG_LOG("New Pet has guid %u", GetGUIDLow());
 
     if (owner->GetTypeId() == TYPEID_PLAYER)
     {
         ((Player*)owner)->PetSpellInitialize();
@@ -479,10 +481,12 @@ void Pet::DeleteFromDB(uint32 guidlow, bool separate_transaction)
     stmt.PExecute(guidlow);
 
     stmt = CharacterDatabase.CreateStatement(delSpellCD, "DELETE FROM pet_spell_cooldown WHERE guid = ?");
     stmt.PExecute(guidlow);
 
+    sMercenaryMgr->OnDelete(guidlow);
+
     if (separate_transaction)
         { CharacterDatabase.CommitTransaction(); }
 }

 
@@ -74,10 +74,11 @@
 #include "Calendar.h"
 #include "LFGMgr.h"
 #ifdef ENABLE_ELUNA
 #include "LuaEngine.h"
 #endif /*ENABLE_ELUNA*/
+#include "MercenaryMgr.h"
 
 #include <cmath>
 
 #define ZONE_UPDATE_INTERVAL (1*IN_MILLISECONDS)
 
@@ -17414,11 +17418,14 @@ void Player::SaveToDB()
     if (m_session->isLogingOut() || !sWorld.getConfig(CONFIG_BOOL_STATS_SAVE_ONLY_ON_LOGOUT))
         _SaveStats();
 
     // save pet (hunter pet level and experience and all type pets health/mana).
     if (Pet* pet = GetPet())
+    {
         pet->SavePetToDB(PET_SAVE_AS_CURRENT);
+        sMercenaryMgr->OnSave(this, pet);
+    }
 }
 
 // fast save function for item/money cheating preventing - save only inventory and money state
 void Player::SaveInventoryAndGoldToDB()
 {
 
 @@ -824,10 +824,13 @@ bool Creature::UpdateStats(Stats /*stat*/)
     return true;
 }
 
 bool Creature::UpdateAllStats()
 {
+    if (GetScriptName() == "mercenary_bot")
+        return false;
+
     UpdateMaxHealth();
     UpdateAttackPowerAndDamage();
 
     for (int i = POWER_MANA; i < MAX_POWERS; ++i)
         { UpdateMaxPower(Powers(i)); }
@@ -849,30 +852,42 @@ void Creature::UpdateResistances(uint32 school)
         { UpdateArmor(); }
 }
 
 void Creature::UpdateArmor()
 {
+   if (GetScriptName() == "mercenary_bot")
+       return;
+
     float value = GetTotalAuraModValue(UNIT_MOD_ARMOR);
     SetArmor(int32(value));
 }
 
 void Creature::UpdateMaxHealth()
 {
+    if (GetScriptName() == "mercenary_bot")
+        return;
+
     float value = GetTotalAuraModValue(UNIT_MOD_HEALTH);
     SetMaxHealth((uint32)value);
 }
 
 void Creature::UpdateMaxPower(Powers power)
 {
+    if (GetScriptName() == "mercenary_bot")
+        return;
+
     UnitMods unitMod = UnitMods(UNIT_MOD_POWER_START + power);
 
     float value  = GetTotalAuraModValue(unitMod);
     SetMaxPower(power, uint32(value));
 }
 
 void Creature::UpdateAttackPowerAndDamage(bool ranged)
 {
+    if (GetScriptName() == "mercenary_bot")
+        return;
+
     UnitMods unitMod = ranged ? UNIT_MOD_ATTACK_POWER_RANGED : UNIT_MOD_ATTACK_POWER;
 
     uint16 index = UNIT_FIELD_ATTACK_POWER;
     uint16 index_mod = UNIT_FIELD_ATTACK_POWER_MODS;
     uint16 index_mult = UNIT_FIELD_ATTACK_POWER_MULTIPLIER;
@@ -903,10 +918,13 @@ void Creature::UpdateAttackPowerAndDamage(bool ranged)
 void Creature::UpdateDamagePhysical(WeaponAttackType attType)
 {
     if (attType > OFF_ATTACK)
         { return; }
 
+    if (GetScriptName() == "mercenary_bot")
+        return;
+
     UnitMods unitMod = (attType == BASE_ATTACK ? UNIT_MOD_DAMAGE_MAINHAND : UNIT_MOD_DAMAGE_OFFHAND);
 
     /* difference in AP between current attack power and base value from DB */
     float att_pwr_change = GetTotalAttackPowerValue(attType) - GetCreatureInfo()->MeleeAttackPower;
     float base_value  = GetModifierValue(unitMod, BASE_VALUE) + (att_pwr_change * GetAPMultiplier(attType, false) / 14.0f);
@@ -934,10 +952,13 @@ void Creature::UpdateDamagePhysical(WeaponAttackType attType)
 bool Pet::UpdateStats(Stats stat)
 {
     if (stat > STAT_SPIRIT)
         { return false; }
 
+    if (GetScriptName() == "mercenary_bot")
+        return false;
+
     // value = ((base_value * base_pct) + total_value) * total_pct
     float value  = GetTotalStatValue(stat);
 
     Unit* owner = GetOwner();
     if (stat == STAT_STAMINA)
	 
@@ -32,10 +32,11 @@
 #include "Opcodes.h"
 #include "Spell.h"
 #include "ScriptMgr.h"
 #include "Totem.h"
 #include "SpellAuras.h"
+#include "MercenaryMgr.h"
 
 void WorldSession::HandleUseItemOpcode(WorldPacket& recvPacket)
 {
     uint8 bagIndex, slot;
     uint8 unk_flags;                                        // flags (if 0x02 - some additional data are received)
@@ -651,10 +652,43 @@ void WorldSession::HandleGetMirrorimageData(WorldPacket& recv_data)
     Creature* pCreature = _player->GetMap()->GetAnyTypeCreature(guid);
 
     if (!pCreature)
         return;
 
+   if (pCreature->IsPet())
+   {
+       Mercenary* mercenary = sMercenaryMgr->GetMercenary(pCreature->GetCharmInfo()->GetPetNumber());
+       if (mercenary)
+       {
+           WorldPacket data(SMSG_MIRRORIMAGE_DATA, 68);
+           data << pCreature->GetObjectGuid();
+           data << uint32(mercenary->GetDisplay());
+           data << uint8(mercenary->GetRace());
+           data << uint8(mercenary->GetGender());
+           data << uint8(1);
+           data << uint8(0); // Skin
+           data << uint8(0); // Face
+           data << uint8(0); // Hair
+           data << uint8(0); // Hair color
+           data << uint8(0); // Facial hair
+           data << uint32(0);
+           data << uint32(sMercenaryMgr->GetItemDisplayId(mercenary->GetItemBySlot(SLOT_HEAD)));
+           data << uint32(sMercenaryMgr->GetItemDisplayId(mercenary->GetItemBySlot(SLOT_SHOULDERS)));
+           data << uint32(0); // Shirt?
+           data << uint32(sMercenaryMgr->GetItemDisplayId(mercenary->GetItemBySlot(SLOT_CHEST)));
+           data << uint32(0); // Waist
+           data << uint32(sMercenaryMgr->GetItemDisplayId(mercenary->GetItemBySlot(SLOT_LEGS)));
+           data << uint32(sMercenaryMgr->GetItemDisplayId(mercenary->GetItemBySlot(SLOT_FEET)));
+           data << uint32(0); // Wrists
+           data << uint32(sMercenaryMgr->GetItemDisplayId(mercenary->GetItemBySlot(SLOT_HANDS)));
+           data << uint32(0); // Cloak
+           data << uint32(0); // Tabard
+           SendPacket(&data);
+           return;
+      }
+   }
+
     Unit::AuraList const& images = pCreature->GetAurasByType(SPELL_AURA_MIRROR_IMAGE);
 
     if (images.empty())
         return;
 

@@ -117,11 +117,11 @@ DBCStorage <HolidaysEntry>                sHolidaysStore(Holidaysfmt);
 
 DBCStorage <ItemEntry>                    sItemStore(Itemfmt);
 DBCStorage <ItemBagFamilyEntry>           sItemBagFamilyStore(ItemBagFamilyfmt);
 DBCStorage <ItemClassEntry>               sItemClassStore(ItemClassfmt);
 // DBCStorage <ItemCondExtCostsEntry> sItemCondExtCostsStore(ItemCondExtCostsEntryfmt);
-// DBCStorage <ItemDisplayInfoEntry> sItemDisplayInfoStore(ItemDisplayTemplateEntryfmt); -- not used currently
+DBCStorage <ItemDisplayInfoEntry> sItemDisplayInfoStore(ItemDisplayTemplateEntryfmt);
 DBCStorage <ItemExtendedCostEntry> sItemExtendedCostStore(ItemExtendedCostEntryfmt);
 DBCStorage <ItemLimitCategoryEntry> sItemLimitCategoryStore(ItemLimitCategoryEntryfmt);
 DBCStorage <ItemRandomPropertiesEntry> sItemRandomPropertiesStore(ItemRandomPropertiesfmt);
 DBCStorage <ItemRandomSuffixEntry> sItemRandomSuffixStore(ItemRandomSuffixfmt);
 DBCStorage <ItemSetEntry> sItemSetStore(ItemSetEntryfmt);
@@ -167,10 +167,11 @@ DBCStorage <SpellDurationEntry> sSpellDurationStore(SpellDurationfmt);
 DBCStorage <SpellFocusObjectEntry> sSpellFocusObjectStore(SpellFocusObjectfmt);
 DBCStorage <SpellRadiusEntry> sSpellRadiusStore(SpellRadiusfmt);
 DBCStorage <SpellRangeEntry> sSpellRangeStore(SpellRangefmt);
 DBCStorage <SpellRuneCostEntry> sSpellRuneCostStore(SpellRuneCostfmt);
 DBCStorage <SpellShapeshiftFormEntry> sSpellShapeshiftFormStore(SpellShapeshiftFormfmt);
+DBCStorage <SpellIconEntry> sSpellIconStore(SpellIconEntryfmt);
 DBCStorage <StableSlotPricesEntry> sStableSlotPricesStore(StableSlotPricesfmt);
 DBCStorage <SummonPropertiesEntry> sSummonPropertiesStore(SummonPropertiesfmt);
 DBCStorage <TalentEntry> sTalentStore(TalentEntryfmt);
 TalentSpellPosMap sTalentSpellPosMap;
 DBCStorage <TalentTabEntry> sTalentTabStore(TalentTabEntryfmt);
@@ -457,11 +458,11 @@ void LoadDBCStores(const std::string& dataPath)
     LoadDBC(availableDbcLocales, bar, bad_dbc_files, sGtRegenMPPerSptStore,     dbcPath, "gtRegenMPPerSpt.dbc");
     LoadDBC(availableDbcLocales, bar, bad_dbc_files, sHolidaysStore,            dbcPath, "Holidays.dbc");
     LoadDBC(availableDbcLocales, bar, bad_dbc_files, sItemStore,                dbcPath, "Item.dbc");
     LoadDBC(availableDbcLocales, bar, bad_dbc_files, sItemBagFamilyStore,       dbcPath, "ItemBagFamily.dbc");
     LoadDBC(availableDbcLocales, bar, bad_dbc_files, sItemClassStore,           dbcPath, "ItemClass.dbc");
-    // LoadDBC(availableDbcLocales,bar,bad_dbc_files,sItemDisplayInfoStore,     dbcPath,"ItemDisplayInfo.dbc");     -- not used currently
+    LoadDBC(availableDbcLocales, bar, bad_dbc_files, sItemDisplayInfoStore,     dbcPath,"ItemDisplayInfo.dbc");
     // LoadDBC(availableDbcLocales,bar,bad_dbc_files,sItemCondExtCostsStore,    dbcPath,"ItemCondExtCosts.dbc");
     LoadDBC(availableDbcLocales, bar, bad_dbc_files, sItemExtendedCostStore,    dbcPath, "ItemExtendedCost.dbc");
     LoadDBC(availableDbcLocales, bar, bad_dbc_files, sItemLimitCategoryStore,   dbcPath, "ItemLimitCategory.dbc");
     LoadDBC(availableDbcLocales, bar, bad_dbc_files, sItemRandomPropertiesStore, dbcPath, "ItemRandomProperties.dbc");
     LoadDBC(availableDbcLocales, bar, bad_dbc_files, sItemRandomSuffixStore,    dbcPath, "ItemRandomSuffix.dbc");
@@ -543,10 +544,11 @@ void LoadDBCStores(const std::string& dataPath)
     LoadDBC(availableDbcLocales, bar, bad_dbc_files, sSpellItemEnchantmentConditionStore, dbcPath, "SpellItemEnchantmentCondition.dbc");
     LoadDBC(availableDbcLocales, bar, bad_dbc_files, sSpellRadiusStore,         dbcPath, "SpellRadius.dbc");
     LoadDBC(availableDbcLocales, bar, bad_dbc_files, sSpellRangeStore,          dbcPath, "SpellRange.dbc");
     LoadDBC(availableDbcLocales, bar, bad_dbc_files, sSpellRuneCostStore,       dbcPath, "SpellRuneCost.dbc");
     LoadDBC(availableDbcLocales, bar, bad_dbc_files, sSpellShapeshiftFormStore, dbcPath, "SpellShapeshiftForm.dbc");
+    LoadDBC(availableDbcLocales, bar, bad_dbc_files, sSpellIconStore,           dbcPath, "SpellIcon.dbc");
     LoadDBC(availableDbcLocales, bar, bad_dbc_files, sStableSlotPricesStore,    dbcPath, "StableSlotPrices.dbc");
     LoadDBC(availableDbcLocales, bar, bad_dbc_files, sSummonPropertiesStore,    dbcPath, "SummonProperties.dbc");
     LoadDBC(availableDbcLocales, bar, bad_dbc_files, sTalentStore,              dbcPath, "Talent.dbc");
 
     // create talent spells set

@@ -149,11 +149,11 @@ extern DBCStorage <GtRegenHPPerSptEntry>         sGtRegenHPPerSptStore;
 extern DBCStorage <GtRegenMPPerSptEntry>         sGtRegenMPPerSptStore;
 extern DBCStorage <HolidaysEntry>                sHolidaysStore;
 extern DBCStorage <ItemEntry>                    sItemStore;
 extern DBCStorage <ItemBagFamilyEntry>           sItemBagFamilyStore;
 extern DBCStorage <ItemClassEntry>               sItemClassStore;
-// extern DBCStorage <ItemDisplayInfoEntry>      sItemDisplayInfoStore; -- not used currently
+extern DBCStorage <ItemDisplayInfoEntry>      sItemDisplayInfoStore;
 extern DBCStorage <ItemExtendedCostEntry>        sItemExtendedCostStore;
 extern DBCStorage <ItemLimitCategoryEntry>       sItemLimitCategoryStore;
 extern DBCStorage <ItemRandomPropertiesEntry>    sItemRandomPropertiesStore;
 extern DBCStorage <ItemRandomSuffixEntry>        sItemRandomSuffixStore;
 extern DBCStorage <ItemSetEntry>                 sItemSetStore;
@@ -189,10 +189,11 @@ extern PetFamilySpellsStore                      sPetFamilySpellsStore;
 extern DBCStorage <SpellRadiusEntry>             sSpellRadiusStore;
 extern DBCStorage <SpellRangeEntry>              sSpellRangeStore;
 extern DBCStorage <SpellRuneCostEntry>           sSpellRuneCostStore;
 extern DBCStorage <SpellShapeshiftFormEntry>     sSpellShapeshiftFormStore;
 extern DBCStorage <SpellEntry>                   sSpellStore;
+extern DBCStorage <SpellIconEntry>               sSpellIconStore;
 extern DBCStorage <StableSlotPricesEntry>        sStableSlotPricesStore;
 extern DBCStorage <SummonPropertiesEntry>        sSummonPropertiesStore;
 extern DBCStorage <TalentEntry>                  sTalentStore;
 extern DBCStorage <TalentTabEntry>               sTalentTabStore;
 extern DBCStorage <TaxiNodesEntry>               sTaxiNodesStore;

@@ -1133,10 +1133,11 @@ struct ItemClassEntry
 };
 
 struct ItemDisplayInfoEntry
 {
     uint32      ID;                                         // 0        m_ID
+    char* inventoryIcon;
     // 1        m_modelName[2]
     // 2        m_modelTexture[2]
     // 3        m_inventoryIcon
     // 4        m_geosetGroup[3]
     // 5        m_flags
@@ -1912,10 +1913,16 @@ struct SpellItemEnchantmentConditionEntry
     uint8   CompareColor[5];                                // 15-20    m_rt_operandType[5]
     uint32  Value[5];                                       // 21-25    m_rt_operand[5]
     // uint8   Logic[5]                                     // 25-30    m_logic[5]
 };
 
+struct SpellIconEntry
+{
+    uint32 ID;                                              // 0
+    char* spellIcon;                                        // 1
+};
+
 struct StableSlotPricesEntry
 {
     uint32 Slot;                                            //          m_ID
     uint32 Price;                                           //          m_cost
 };

@@ -73,11 +73,11 @@ const char GtRegenHPPerSptfmt[] = "f";
 const char GtRegenMPPerSptfmt[] = "f";
 const char Holidaysfmt[] = "nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
 const char Itemfmt[] = "niiiiiii";
 const char ItemBagFamilyfmt[] = "nxxxxxxxxxxxxxxxxx";
 const char ItemClassfmt[] = "nxxssssssssssssssssx";
-// const char ItemDisplayTemplateEntryfmt[]="nxxxxxxxxxxixxxxxxxxxxx";
+const char ItemDisplayTemplateEntryfmt[] = "nxxxxsxxxxxxxxxxxxxxxxxxx";
 // const char ItemCondExtCostsEntryfmt[]="xiii";
 const char ItemExtendedCostEntryfmt[] = "niiiiiiiiiiiiiix";
 const char ItemLimitCategoryEntryfmt[] = "nxxxxxxxxxxxxxxxxxii";
 const char ItemRandomPropertiesfmt[] = "nxiiiiissssssssssssssssx";
 const char ItemRandomSuffixfmt[] = "nssssssssssssssssxxiiiiiiiiii";
@@ -111,10 +111,11 @@ const char SpellItemEnchantmentfmt[] = "nxiiiiiixxxiiissssssssssssssssxiiiixxx";
 const char SpellItemEnchantmentConditionfmt[] = "nbbbbbxxxxxbbbbbbbbbbiiiiiXXXXX";
 const char SpellRadiusfmt[] = "nfxx";
 const char SpellRangefmt[] = "nffffxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
 const char SpellRuneCostfmt[] = "niiii";
 const char SpellShapeshiftFormfmt[] = "nxxxxxxxxxxxxxxxxxxiixiiixxiiiiiiii";
+char const SpellIconEntryfmt[] = "ns";
 const char StableSlotPricesfmt[] = "ni";
 const char SummonPropertiesfmt[] = "niiiii";
 const char TalentEntryfmt[] = "niiiiiiiixxxxixxixxxxxx";
 const char TalentTabEntryfmt[] = "nxxxxxxxxxxxxxxxxxxxiiix";
 const char TaxiNodesEntryfmt[] = "nifffssssssssssssssssxii";

